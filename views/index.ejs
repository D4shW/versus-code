<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>VersusCode - Éditeur de Code</title>
  
  <link rel="icon" href="/favicon.ico" type="image/x-icon">
  <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
  
  <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
  
  <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.43.0/min/vs/loader.js"></script>
  
  <script src="https://cdn.tailwindcss.com"></script>
  
  <link href='https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css' rel='stylesheet'>
  <link rel="stylesheet" href="/styles.css">
</head>
<body class="bg-gray-900 text-white h-screen overflow-hidden">
  <div id="app" class="h-full flex flex-col">


<header class="bg-gray-800 p-3 flex items-center border-b border-gray-700">
  
  <div class="flex items-center">
    <img src="/logo-vscode.png" alt="VS Code Logo" class="h-8" title="VersusCode">
  </div>
  
  
  <div class="flex-1"></div>
  
  
  <div class="flex items-center space-x-4">
    <label for="file-upload" class="cursor-pointer bg-blue-600 hover:bg-blue-700 px-3 py-1 rounded text-sm flex items-center">
      <i class='bx bx-upload mr-1'></i> Importer
      <input id="file-upload" type="file" class="hidden" @change="uploadFile" accept=".txt,.js,.html,.css,.go,.py">
    </label>
    <button @click="saveFile" class="bg-green-600 hover:bg-green-700 px-3 py-1 rounded text-sm flex items-center" :disabled="!currentFile">
      <i class='bx bx-save mr-1'></i> Sauvegarder
    </button>
    <button @click="saveFileAs" class="bg-green-600 hover:bg-green-700 px-3 py-1 rounded text-sm flex items-center" :disabled="!currentFile">
      <i class='bx bx-export mr-1'></i> {{ hasFileSystemAccessAPI ? 'Enregistrer sur le disque' : 'Télécharger' }}
    </button>
  </div>
</header>
    
    
    <main class="flex flex-1 overflow-hidden">
      
      <aside class="w-64 bg-gray-800 border-r border-gray-700 flex flex-col">
        <div class="p-2 text-gray-400 font-semibold flex items-center justify-between">
          <span>EXPLORATEUR</span>
          <div class="flex items-center space-x-2">
            <button @click="showCreateModal = true; createModalType = 'file'" class="bg-blue-600 hover:bg-blue-700 p-1 rounded text-white flex items-center" title="Nouveau fichier">
              <i class='bx bx-plus'></i>
            </button>
            <button @click="showCreateModal = true; createModalType = 'folder'" class="bg-blue-600 hover:bg-blue-700 p-1 rounded text-white flex items-center" title="Nouveau dossier">
              <i class='bx bx-folder-plus'></i>
            </button>
            <button @click="loadFileTree" class="hover:text-blue-300" title="Rafraîchir">
              <i class='bx bx-refresh'></i>
            </button>
          </div>
        </div>
        <div class="flex-1 overflow-y-auto p-2 space-y-1">
          <div v-if="loading" class="text-center py-4 text-gray-500">
            <i class='bx bx-loader-alt bx-spin text-xl'></i>
            <p>Chargement...</p>
          </div>
          <div v-else-if="fileTree.folders.length === 0 && fileTree.files.length === 0" class="text-center py-4 text-gray-500">
            <i class='bx bx-file text-xl'></i>
            <p>Aucun fichier</p>
          </div>
          <div v-else>
            
            <file-tree-item 
              v-for="folder in fileTree.folders" 
              :key="'folder-' + folder.id" 
              :item="folder" 
              :type="'folder'"
              :depth="0"
              @open-file="openFile" 
              @toggle-folder="toggleFolder"
              @delete-item="confirmDeleteItem"
              @create-in-folder="createInFolder"
              @rename-item="startRenameItem"
            ></file-tree-item>
            
            <file-tree-item 
              v-for="file in fileTree.files" 
              :key="'file-' + file.id" 
              :item="file" 
              :type="'file'"
              :depth="0"
              @open-file="openFile" 
              @delete-item="confirmDeleteItem"
              @rename-item="startRenameItem"
            ></file-tree-item>
          </div>
        </div>
      </aside>
      
      
      <section class="flex-1 flex flex-col bg-gray-900">
        <div v-if="!currentFile" class="flex-1 flex items-center justify-center text-gray-400 flex-col">
          <i class='bx bx-code-curly text-6xl mb-4'></i>
          <h2 class="text-xl mb-4">Bienvenue sur VersusCode</h2>
          <p class="text-center max-w-md">
            Importez un fichier ou sélectionnez-en un dans l'explorateur pour commencer à éditer.
          </p>
        </div>
        <div v-else class="flex-1 flex flex-col">
          <div class="bg-gray-800 px-3 py-2 text-sm border-b border-gray-700 flex items-center justify-between">
            <div class="flex items-center">
              <i class='bx bx-code-alt text-blue-400 mr-2'></i>
              <span>{{ currentFile.path }}</span>
            </div>
            <div v-if="currentFile.unsaved" class="text-orange-400 text-xs">
              <i class='bx bx-circle'></i> Non sauvegardé
            </div>
          </div>
          <div id="editor" class="flex-1"></div>
        </div>
      </section>
    </main>
    
    
    <footer class="bg-blue-600 text-white p-1 text-xs flex items-center">
      <div class="ml-2">{{ statusMessage }}</div>
      <div class="flex-1"></div>
      <div class="mr-2" v-if="currentFile">UTF-8</div>
    </footer>
    
    
    <div class="fixed bottom-5 right-5 z-50">
      <div v-for="(toast, index) in toasts" :key="index" 
           class="mb-2 p-3 rounded shadow-lg max-w-sm transition-all"
           :class="toast.type === 'error' ? 'bg-red-500' : 'bg-green-500'">
        {{ toast.message }}
      </div>
    </div>
    
    
    <div v-if="showCreateModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div class="bg-gray-800 rounded-lg shadow-xl w-full max-w-md p-6 border border-gray-700">
        <div class="flex justify-between items-center mb-4">
          <h3 class="text-xl font-medium text-blue-400">
            {{ createModalType === 'file' ? 'Créer un nouveau fichier' : 'Créer un nouveau dossier' }}
            <span v-if="createInFolderPath" class="text-sm text-gray-400 block mt-1">
              dans {{ createInFolderPath }}
            </span>
          </h3>
          <button @click="showCreateModal = false" class="text-gray-400 hover:text-white">
            <i class='bx bx-x text-2xl'></i>
          </button>
        </div>
        
        <form @submit.prevent="createNewItem">
          <div class="mb-4">
            <label :for="createModalType === 'file' ? 'fileName' : 'folderName'" class="block mb-2 text-sm font-medium text-gray-300">
              {{ createModalType === 'file' ? 'Nom du fichier' : 'Nom du dossier' }}
            </label>
            <input type="text" 
                  :id="createModalType === 'file' ? 'fileName' : 'folderName'" 
                  v-model="newItemName" 
                  class="bg-gray-700 border border-gray-600 text-white text-sm rounded block w-full p-2.5 focus:ring-blue-500 focus:border-blue-500" 
                  :placeholder="createModalType === 'file' ? 'exemple' : 'nouveau-dossier'" 
                  required>
          </div>
          
          <div class="mb-4" v-if="createModalType === 'file'">
            <label for="fileType" class="block mb-2 text-sm font-medium text-gray-300">Type de fichier</label>
            <select id="fileType" v-model="newFileType" 
                   class="bg-gray-700 border border-gray-600 text-white text-sm rounded block w-full p-2.5 focus:ring-blue-500 focus:border-blue-500">
              <option value="js">JavaScript (.js)</option>
              <option value="html">HTML (.html)</option>
              <option value="css">CSS (.css)</option>
              <option value="py">Python (.py)</option>
              <option value="go">Go (.go)</option>
              <option value="txt">Texte (.txt)</option>
              <option value="md">Markdown (.md)</option>
            </select>
          </div>
          
          <div class="flex justify-end space-x-3">
            <button type="button" @click="showCreateModal = false"
                   class="px-4 py-2 bg-gray-700 hover:bg-gray-600 text-white rounded">
              Annuler
            </button>
            <button type="submit"
                   class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded">
              Créer
            </button>
          </div>
        </form>
      </div>
    </div>
    
    
    <div v-if="showRenameModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div class="bg-gray-800 rounded-lg shadow-xl w-full max-w-md p-6 border border-gray-700">
        <div class="flex justify-between items-center mb-4">
          <h3 class="text-xl font-medium text-blue-400">
            Renommer {{ renameItem.type === 'file' ? 'le fichier' : 'le dossier' }}
          </h3>
          <button @click="showRenameModal = false" class="text-gray-400 hover:text-white">
            <i class='bx bx-x text-2xl'></i>
          </button>
        </div>
        
        <form @submit.prevent="renameItemConfirm">
          <div class="mb-4">
            <label for="newName" class="block mb-2 text-sm font-medium text-gray-300">
              Nouveau nom
            </label>
            <input type="text" 
                  id="newName" 
                  v-model="newItemName" 
                  class="bg-gray-700 border border-gray-600 text-white text-sm rounded block w-full p-2.5 focus:ring-blue-500 focus:border-blue-500" 
                  required>
          </div>
          
          <div class="flex justify-end space-x-3">
            <button type="button" @click="showRenameModal = false"
                   class="px-4 py-2 bg-gray-700 hover:bg-gray-600 text-white rounded">
              Annuler
            </button>
            <button type="submit"
                   class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded">
              Renommer
            </button>
          </div>
        </form>
      </div>
    </div>
  </div>

  
  <template id="file-tree-item-template">
    <div 
      class="file-tree-item"
      :style="{ paddingLeft: `${depth * 16}px` }"
    >
      
      <template v-if="type === 'folder'">
        <div 
          class="flex items-center justify-between p-1 hover:bg-gray-700 rounded cursor-pointer group relative"
          @click="toggleFolder(item)"
        >
          <div class="flex items-center flex-grow truncate">
            <i 
              :class="[
                'bx mr-1', 
                item.isExpanded ? 'bx-folder-open text-yellow-400' : 'bx-folder text-yellow-400'
              ]"
            ></i>
            <span class="truncate">{{ item.name }}</span>
          </div>
          <div class="flex opacity-0 group-hover:opacity-100 transition-opacity">
            <button @click.stop="$emit('create-in-folder', item, 'file')" title="Nouveau fichier" class="text-gray-400 hover:text-blue-400 mx-1">
              <i class='bx bx-file-blank'></i>
            </button>
            <button @click.stop="$emit('create-in-folder', item, 'folder')" title="Nouveau dossier" class="text-gray-400 hover:text-blue-400 mx-1">
              <i class='bx bx-folder-plus'></i>
            </button>
            <button @click.stop="$emit('rename-item', { type, item })" title="Renommer" class="text-gray-400 hover:text-yellow-400 mx-1">
              <i class='bx bx-rename'></i>
            </button>
            <button @click.stop="$emit('delete-item', { type, item })" title="Supprimer" class="text-gray-400 hover:text-red-400 mx-1">
              <i class='bx bx-trash'></i>
            </button>
          </div>
        </div>
        
        
        <div v-if="item.isExpanded" class="ml-1 pl-1 border-l border-gray-600">
          
          <file-tree-item 
            v-for="childFolder in item.folders" 
            :key="'folder-' + childFolder.id" 
            :item="childFolder" 
            :type="'folder'"
            :depth="depth + 1"
            @open-file="$emit('open-file', $event)" 
            @toggle-folder="$emit('toggle-folder', $event)"
            @delete-item="$emit('delete-item', $event)"
            @create-in-folder="$emit('create-in-folder', $event, $event2)"
            @rename-item="$emit('rename-item', $event)"
          ></file-tree-item>
          
          
          <file-tree-item 
            v-for="childFile in item.files" 
            :key="'file-' + childFile.id" 
            :item="childFile" 
            :type="'file'"
            :depth="depth + 1"
            @open-file="$emit('open-file', $event)" 
            @delete-item="$emit('delete-item', $event)"
            @rename-item="$emit('rename-item', $event)"
          ></file-tree-item>
        </div>
      </template>
      
      
      <template v-else>
        <div 
          @click="$emit('open-file', item)"
          class="flex items-center justify-between p-1 hover:bg-gray-700 rounded cursor-pointer group"
          :class="{'bg-gray-700': isActive}"
        >
          <div class="flex items-center truncate">
            <i class="bx mr-1" :class="getFileIcon(item.name)"></i>
            <span class="truncate">{{ item.name }}</span>
          </div>
          <div class="flex opacity-0 group-hover:opacity-100 transition-opacity">
            <button @click.stop="$emit('rename-item', { type, item })" title="Renommer" class="text-gray-400 hover:text-yellow-400 mx-1">
              <i class='bx bx-rename'></i>
            </button>
            <button @click.stop="$emit('delete-item', { type, item })" title="Supprimer" class="text-gray-400 hover:text-red-400 mx-1">
              <i class='bx bx-trash'></i>
            </button>
          </div>
        </div>
      </template>
    </div>
  </template>

  <script>
    
    let editor = null;
    let hasEditorChanges = false;

    
    function initMonaco() {
      require.config({ paths: { 'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.43.0/min/vs' }});
      window.MonacoEnvironment = { getWorkerUrl: () => proxy };
      
      let proxy = URL.createObjectURL(new Blob([`
        self.MonacoEnvironment = {
          baseUrl: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.43.0/min/'
        };
        importScripts('https://cdn.jsdelivr.net/npm/monaco-editor@0.43.0/min/vs/base/worker/workerMain.js');
      `], { type: 'text/javascript' }));
    }

    initMonaco();

    
    const FileTreeItem = {
      name: 'FileTreeItem',
      template: '#file-tree-item-template',
      props: {
        item: Object,
        type: String,
        depth: {
          type: Number,
          default: 0
        }
      },
      computed: {
        isActive() {
          
          return this.$root.currentFile && this.$root.currentFile.id === this.item.id;
        }
      },
      methods: {
        toggleFolder(folder) {
          this.$emit('toggle-folder', folder);
        },
        getFileIcon(fileName) {
          const ext = fileName.split('.').pop().toLowerCase();
          const iconMap = {
            'js': 'bx-code-alt text-yellow-300',
            'html': 'bx-code text-orange-400',
            'css': 'bx-palette text-blue-400',
            'py': 'bx-code-curly text-green-400',
            'go': 'bx-code-block text-blue-300',
            'txt': 'bx-file text-gray-400',
            'md': 'bx-book text-white',
            'json': 'bx-brackets-curly text-yellow-200',
          };
          
          return iconMap[ext] || 'bx-file text-gray-400';
        }
      }
    };

    
    const { createApp } = Vue;
    
    const app = createApp({
      components: {
        FileTreeItem
      },
      data() {
        return {
          
          fileTree: {
            folders: [],
            files: []
          },
          currentFile: null,
          loading: false,
          statusMessage: 'Prêt',
          toasts: [],
          
          
          showCreateModal: false,
          createModalType: 'file', 
          newItemName: '',
          newFileType: 'js',
          createInFolderPath: null,
          createInFolderId: null,
          
          showRenameModal: false,
          renameItem: null,
          
          
          fileHandles: new Map(),
          hasFileSystemAccessAPI: false
        }
      },
      mounted() {
        this.loadFileTree();
        
        
        this.checkBrowserCapabilities();
      },
      methods: {
        
        generateId() {
          return Date.now().toString() + Math.floor(Math.random() * 1000);
        },
        
        
        saveFileTree() {
          try {
            
            const serializedTree = JSON.stringify(this.fileTree);
            localStorage.setItem('versusCodeFileTree', serializedTree);
          } catch (error) {
            console.error('Erreur lors de la sauvegarde de l\'arborescence:', error);
            this.showToast('Erreur lors de la sauvegarde de l\'arborescence', 'error');
          }
        },
        
        
        loadFileTree() {
          this.loading = true;
          
          try {
            const storedTree = localStorage.getItem('versusCodeFileTree');
            
            if (storedTree) {
              this.fileTree = JSON.parse(storedTree);
            } else {
              
              this.fileTree = {
                folders: [],
                files: []
              };
            }
            
            
            const fileCount = this.countFiles(this.fileTree);
            const folderCount = this.countFolders(this.fileTree);
            
            this.statusMessage = `${folderCount} dossier(s), ${fileCount} fichier(s)`;
          } catch (error) {
            console.error('Erreur lors du chargement de l\'arborescence:', error);
            this.showToast('Erreur lors du chargement de l\'arborescence', 'error');
            
            
            this.fileTree = {
              folders: [],
              files: []
            };
          } finally {
            this.loading = false;
          }
        },
        
        
        countFiles(node) {
          let count = node.files ? node.files.length : 0;
          
          if (node.folders) {
            for (const folder of node.folders) {
              count += this.countFiles(folder);
            }
          }
          
          return count;
        },
        
        
        countFolders(node) {
          let count = node.folders ? node.folders.length : 0;
          
          if (node.folders) {
            for (const folder of node.folders) {
              count += this.countFolders(folder);
            }
          }
          
          return count;
        },
        
        
        openFile(file) {
          this.statusMessage = `Ouverture de ${file.name}...`;
          
          try {
            
            const path = this.getFilePath(file);
            
            this.currentFile = {
              id: file.id,
              name: file.name,
              content: file.content,
              path: path,
              unsaved: false
            };
            
            this.initEditor(file.content, this.getFileLanguage(file.name));
            this.statusMessage = `Fichier ${file.name} ouvert`;
          } catch (error) {
            console.error('Erreur lors de l\'ouverture du fichier:', error);
            this.showToast(`Erreur lors de l'ouverture du fichier: ${file.name}`, 'error');
            this.statusMessage = 'Prêt';
          }
        },
        
        
        getFilePath(file, currentPath = '') {
          
          if (file.fullPath) return file.fullPath;
          
          
          return this.findFilePath(this.fileTree, file.id) || file.name;
        },
        
        
        findFilePath(node, fileId, currentPath = '') {
          
          if (node.files) {
            for (const file of node.files) {
              if (file.id === fileId) {
                return currentPath ? `${currentPath}/${file.name}` : file.name;
              }
            }
          }
          
          
          if (node.folders) {
            for (const folder of node.folders) {
              const path = currentPath ? `${currentPath}/${folder.name}` : folder.name;
              const foundPath = this.findFilePath(folder, fileId, path);
              if (foundPath) return foundPath;
            }
          }
          
          return null;
        },
        
        
        initEditor(content, language) {
          require(['vs/editor/editor.main'], () => {
            if (editor) {
              editor.dispose();
            }
            
            editor = monaco.editor.create(document.getElementById('editor'), {
              value: content,
              language: language,
              theme: 'vs-dark',
              automaticLayout: true,
              minimap: {
                enabled: true
              },
              scrollBeyondLastLine: false,
              fontSize: 14,
              lineNumbers: 'on',
              roundedSelection: true,
              scrollBeyondLastLine: false,
              readOnly: false,
              cursorStyle: 'line',
              autoIndent: 'full'
            });
            
            
            editor.onDidChangeModelContent(() => {
              if (this.currentFile) {
                this.currentFile.unsaved = true;
              }
            });
          });
        },
        
        
        getFileLanguage(fileName) {
          const langMap = {
            'js': 'javascript',
            'py': 'python',
            'html': 'html',
            'css': 'css',
            'go': 'go',
            'txt': 'plaintext',
            'json': 'json',
            'md': 'markdown'
          };
          
          const fileExt = fileName.split('.').pop().toLowerCase();
          return langMap[fileExt] || 'plaintext';
        },
        
        
        pathExists(path) {
          if (!path) return false;
          
          
          const segments = path.split('/');
          
          let currentNode = this.fileTree;
          
          for (let i = 0; i < segments.length; i++) {
            const segment = segments[i];
            const isLastSegment = i === segments.length - 1;
            
            
            if (isLastSegment) {
              if (currentNode.files && currentNode.files.some(f => f.name === segment)) {
                return true;
              }
              
              if (currentNode.folders && currentNode.folders.some(f => f.name === segment)) {
                return true;
              }
              return false;
            }
            
            
            let found = false;
            if (currentNode.folders) {
              for (const folder of currentNode.folders) {
                if (folder.name === segment) {
                  currentNode = folder;
                  found = true;
                  break;
                }
              }
            }
            
            if (!found) return false;
          }
          
          return true;
        },
        
        
        toggleFolder(folder) {
          folder.isExpanded = !folder.isExpanded;
          this.saveFileTree();
        },
        
        
        async uploadFile(event) {
          const file = event.target.files[0];
          if (!file) return;
          
          this.statusMessage = `Chargement de ${file.name}...`;
          
          try {
            const reader = new FileReader();
            
            reader.onload = (e) => {
              const content = e.target.result;
              
              
              const fileId = this.generateId();
              
              
              this.fileTree.files.push({
                id: fileId,
                name: file.name,
                content: content,
                lastModified: new Date().toISOString()
              });
              
              
              this.saveFileTree();
              
              
              this.openFile({
                id: fileId,
                name: file.name,
                content: content
              });
              
              this.showToast('Fichier importé avec succès', 'success');
              this.statusMessage = `Fichier ${file.name} importé et ouvert`;
            };
            
            reader.onerror = () => {
              throw new Error("Erreur lors de la lecture du fichier");
            };
            
            reader.readAsText(file);
          } catch (error) {
            this.showToast(`Erreur: ${error.message}`, 'error');
            this.statusMessage = 'Prêt';
          } finally {
            
            event.target.value = '';
          }
        },
        
        
        saveFile() {
          if (!this.currentFile || !editor) return;
          
          this.statusMessage = 'Sauvegarde en cours...';
          
          try {
            const content = editor.getValue();
            
            
            this.updateFileInTree(this.fileTree, this.currentFile.id, content);
            
            
            this.saveFileTree();
            
            
            this.currentFile.content = content;
            this.currentFile.unsaved = false;
            
            this.showToast('Fichier sauvegardé', 'success');
            this.statusMessage = `Fichier ${this.currentFile.name} sauvegardé`;
            
            
            
            if (this.hasFileSystemAccessAPI && this.fileHandles.has(this.currentFile.id)) {
              this.saveFileToHandle(this.currentFile.id, content);
            }
          } catch (error) {
            console.error('Erreur lors de la sauvegarde:', error);
            this.showToast(`Erreur: ${error.message}`, 'error');
            this.statusMessage = 'Prêt';
          }
        },
        
        
        updateFileInTree(node, fileId, content) {
          
          if (node.files) {
            for (let i = 0; i < node.files.length; i++) {
              if (node.files[i].id === fileId) {
                node.files[i].content = content;
                node.files[i].lastModified = new Date().toISOString();
                return true;
              }
            }
          }
          
          
          if (node.folders) {
            for (const folder of node.folders) {
              if (this.updateFileInTree(folder, fileId, content)) {
                return true;
              }
            }
          }
          
          return false;
        },
        
        
        async saveFileAs() {
          if (!this.currentFile || !editor) return;
          
          this.statusMessage = 'Préparation de l\'enregistrement...';
          const content = editor.getValue();
          
          
          if (this.hasFileSystemAccessAPI) {
            try {
              
              const options = {
                suggestedName: this.currentFile.name,
                types: [{
                  description: 'Fichiers texte',
                  accept: this.getFileAcceptType(this.currentFile.name)
                }]
              };
              
              
              const fileHandle = await window.showSaveFilePicker(options);
              
              
              this.fileHandles.set(this.currentFile.id, fileHandle);
              
              
              await this.writeToFile(fileHandle, content);
              
              this.showToast('Fichier enregistré sur le disque', 'success');
              this.statusMessage = `Fichier enregistré sur le disque: ${fileHandle.name}`;
              
              
              if (this.currentFile.name !== fileHandle.name) {
                this.updateFileNameInTree(this.fileTree, this.currentFile.id, fileHandle.name);
                this.currentFile.name = fileHandle.name;
                this.currentFile.path = this.getFilePath({id: this.currentFile.id, name: fileHandle.name});
                this.saveFileTree();
              }
              
              
              this.currentFile.unsaved = false;
            } catch (error) {
              
              if (error.name !== 'AbortError') {
                this.showToast(`Erreur lors de l'enregistrement: ${error.message}`, 'error');
              }
              this.statusMessage = 'Prêt';
            }
          } 
          
          else {
            try {
              
              const blob = new Blob([content], { type: this.getMimeType(this.currentFile.name) });
              
              
              const url = URL.createObjectURL(blob);
              
              
              const a = document.createElement('a');
              a.href = url;
              a.download = this.currentFile.name;
              
              
              document.body.appendChild(a);
              a.click();
              
              
              setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
              }, 0);
              
              this.showToast('Fichier téléchargé', 'success');
              this.statusMessage = `Fichier téléchargé: ${this.currentFile.name}`;
              
              
              this.currentFile.unsaved = false;
            } catch (error) {
              this.showToast(`Erreur lors du téléchargement: ${error.message}`, 'error');
              this.statusMessage = 'Prêt';
            }
          }
        },
        
        
        updateFileNameInTree(node, fileId, newName) {
          
          if (node.files) {
            for (let i = 0; i < node.files.length; i++) {
              if (node.files[i].id === fileId) {
                node.files[i].name = newName;
                return true;
              }
            }
          }
          
          
          if (node.folders) {
            for (const folder of node.folders) {
              if (this.updateFileNameInTree(folder, fileId, newName)) {
                return true;
              }
            }
          }
          
          return false;
        },
        
        
        async saveFileToHandle(fileId, content) {
          const fileHandle = this.fileHandles.get(fileId);
          if (!fileHandle) return;
          
          try {
            await this.writeToFile(fileHandle, content);
            this.showToast(`Fichier enregistré sur le disque: ${fileHandle.name}`, 'success');
          } catch (error) {
            this.showToast(`Erreur lors de l'enregistrement sur le disque: ${error.message}`, 'error');
          }
        },
        
        
        async writeToFile(fileHandle, content) {
          
          const writable = await fileHandle.createWritable();
          
          
          await writable.write(content);
          
          
          await writable.close();
        },
        
        
        getFileAcceptType(fileName) {
          const extension = fileName.split('.').pop().toLowerCase();
          const mimeTypes = {
            'js': { 'application/javascript': ['.js'] },
            'html': { 'text/html': ['.html'] },
            'css': { 'text/css': ['.css'] },
            'py': { 'text/x-python': ['.py'] },
            'go': { 'text/x-go': ['.go'] },
            'txt': { 'text/plain': ['.txt'] },
            'json': { 'application/json': ['.json'] },
            'md': { 'text/markdown': ['.md'] }
          };
          
          return mimeTypes[extension] || { 'text/plain': ['.txt'] };
        },
        
        
        getMimeType(fileName) {
          const extension = fileName.split('.').pop().toLowerCase();
          const mimeTypes = {
            'js': 'application/javascript',
            'html': 'text/html',
            'css': 'text/css',
            'py': 'text/x-python',
            'go': 'text/x-go',
            'txt': 'text/plain',
            'json': 'application/json',
            'md': 'text/markdown'
          };
          
          return mimeTypes[extension] || 'text/plain';
        },
        
        
        checkBrowserCapabilities() {
          this.hasFileSystemAccessAPI = 'showSaveFilePicker' in window;
        },
        
        
        createInFolder(folder, type) {
          this.createInFolderId = folder.id;
          
          this.createInFolderPath = this.getFilePath(folder);
          
          this.createModalType = type;
          this.newItemName = '';
          this.showCreateModal = true;
        },
        
        
        createNewItem() {
          if (!this.newItemName) {
            this.showToast('Veuillez saisir un nom', 'error');
            return;
          }
          
          try {
            if (this.createModalType === 'file') {
              this.createNewFile();
            } else {
              this.createNewFolder();
            }
            
            this.showCreateModal = false;
            this.createInFolderId = null;
            this.createInFolderPath = null;
          } catch (error) {
            this.showToast(`Erreur: ${error.message}`, 'error');
          }
        },
        
        
        createNewFile() {
          
          let fileName = this.newItemName;
          if (!fileName.includes('.') && this.newFileType) {
            fileName = `${fileName}.${this.newFileType}`;
          }
          
          this.statusMessage = `Création du fichier ${fileName}...`;
          
          
          const fullPath = this.createInFolderPath 
            ? `${this.createInFolderPath}/${fileName}`
            : fileName;
          
          if (this.pathExists(fullPath)) {
            throw new Error(`Un élément nommé ${fileName} existe déjà`);
          }
          
          
          const fileId = this.generateId();
          
          
          const newFile = {
            id: fileId,
            name: fileName,
            content: '',
            lastModified: new Date().toISOString()
          };
          
          
          if (this.createInFolderId) {
            this.addFileToFolder(this.fileTree, this.createInFolderId, newFile);
          } else {
            this.fileTree.files.push(newFile);
          }
          
          
          this.saveFileTree();
          
          
          this.openFile(newFile);
          
          this.showToast(`Fichier ${fileName} créé avec succès`, 'success');
          this.newItemName = '';
          this.statusMessage = `Fichier ${fileName} créé et ouvert`;
        },
        
        
        addFileToFolder(node, folderId, file) {
          
          if (node.id === folderId) {
            if (!node.files) node.files = [];
            node.files.push(file);
            return true;
          }
          
          
          if (node.folders) {
            for (const folder of node.folders) {
              if (this.addFileToFolder(folder, folderId, file)) {
                return true;
              }
            }
          }
          
          
          if (node.folders) {
            for (const folder of node.folders) {
              if (folder.id === folderId) {
                if (!folder.files) folder.files = [];
                folder.files.push(file);
                return true;
              }
            }
          }
          
          return false;
        },
        
        
        createNewFolder() {
          const folderName = this.newItemName;
          
          this.statusMessage = `Création du dossier ${folderName}...`;
          
          
          const fullPath = this.createInFolderPath 
            ? `${this.createInFolderPath}/${folderName}`
            : folderName;
          
          if (this.pathExists(fullPath)) {
            throw new Error(`Un élément nommé ${folderName} existe déjà`);
          }
          
          
          const folderId = this.generateId();
          
          
          const newFolder = {
            id: folderId,
            name: folderName,
            isExpanded: true,
            folders: [],
            files: []
          };
          
          
          if (this.createInFolderId) {
            this.addFolderToFolder(this.fileTree, this.createInFolderId, newFolder);
          } else {
            this.fileTree.folders.push(newFolder);
          }
          
          
          this.saveFileTree();
          
          this.showToast(`Dossier ${folderName} créé avec succès`, 'success');
          this.newItemName = '';
          this.statusMessage = `Dossier ${folderName} créé`;
        },
        
        
        addFolderToFolder(node, parentId, folder) {
          
          if (node.id === parentId) {
            if (!node.folders) node.folders = [];
            node.folders.push(folder);
            return true;
          }
          
          
          if (node.folders) {
            for (const childFolder of node.folders) {
              if (this.addFolderToFolder(childFolder, parentId, folder)) {
                return true;
              }
            }
          }
          
          
          if (node.folders) {
            for (const childFolder of node.folders) {
              if (childFolder.id === parentId) {
                if (!childFolder.folders) childFolder.folders = [];
                childFolder.folders.push(folder);
                return true;
              }
            }
          }
          
          return false;
        },
        
        
        confirmDeleteItem(item) {
          const { type, item: targetItem } = item;
          const isFolder = type === 'folder';
          
          const message = isFolder
            ? `Êtes-vous sûr de vouloir supprimer le dossier "${targetItem.name}" et tout son contenu ?`
            : `Êtes-vous sûr de vouloir supprimer le fichier "${targetItem.name}" ?`;
          
          if (confirm(message)) {
            this.deleteItem(type, targetItem.id);
          }
        },
        
        
        deleteItem(type, itemId) {
          if (type === 'file') {
            this.deleteFileFromTree(this.fileTree, itemId);
          } else {
            this.deleteFolderFromTree(this.fileTree, itemId);
          }
          
          
          this.saveFileTree();
          
          
          if (this.currentFile && this.currentFile.id === itemId) {
            this.currentFile = null;
            if (editor) {
              editor.dispose();
              editor = null;
            }
          }
          
          this.showToast(`Élément supprimé`, 'success');
          this.statusMessage = 'Prêt';
        },
        
        
        deleteFileFromTree(node, fileId) {
          
          if (node.files) {
            const index = node.files.findIndex(f => f.id === fileId);
            if (index !== -1) {
              node.files.splice(index, 1);
              return true;
            }
          }
          
          
          if (node.folders) {
            for (const folder of node.folders) {
              if (this.deleteFileFromTree(folder, fileId)) {
                return true;
              }
            }
          }
          
          return false;
        },
        
        
        deleteFolderFromTree(node, folderId) {
          
          if (node.folders) {
            const index = node.folders.findIndex(f => f.id === folderId);
            if (index !== -1) {
              node.folders.splice(index, 1);
              return true;
            }
            
            
            for (const folder of node.folders) {
              if (this.deleteFolderFromTree(folder, folderId)) {
                return true;
              }
            }
          }
          
          return false;
        },
        
        
        startRenameItem(data) {
          this.renameItem = data;
          this.newItemName = data.item.name;
          this.showRenameModal = true;
        },
        
        
        renameItemConfirm() {
          if (!this.newItemName || !this.renameItem) {
            this.showToast('Veuillez saisir un nom valide', 'error');
            return;
          }
          
          try {
            const { type, item } = this.renameItem;
            const oldName = item.name;
            const newName = this.newItemName;
            
            
            if (oldName === newName) {
              this.showRenameModal = false;
              return;
            }
            
            
            const currentPath = this.getFilePath(item);
            const parentPath = currentPath.substring(0, currentPath.lastIndexOf('/'));
            
            
            const newPath = parentPath 
              ? `${parentPath}/${newName}`
              : newName;
            
            if (this.pathExists(newPath)) {
              throw new Error(`Un élément nommé ${newName} existe déjà`);
            }
            
            if (type === 'file') {
              this.renameFileInTree(this.fileTree, item.id, newName);
              
              
              if (this.currentFile && this.currentFile.id === item.id) {
                this.currentFile.name = newName;
                this.currentFile.path = this.getFilePath({id: item.id, name: newName});
              }
            } else {
              this.renameFolderInTree(this.fileTree, item.id, newName);
            }
            
            
            this.saveFileTree();
            
            this.showToast(`"${oldName}" renommé en "${newName}"`, 'success');
            this.showRenameModal = false;
            this.renameItem = null;
            
          } catch (error) {
            this.showToast(`Erreur: ${error.message}`, 'error');
          }
        },
        
        
        renameFileInTree(node, fileId, newName) {
          
          if (node.files) {
            for (let i = 0; i < node.files.length; i++) {
              if (node.files[i].id === fileId) {
                node.files[i].name = newName;
                return true;
              }
            }
          }
          
          
          if (node.folders) {
            for (const folder of node.folders) {
              if (this.renameFileInTree(folder, fileId, newName)) {
                return true;
              }
            }
          }
          
          return false;
        },
        
        
        renameFolderInTree(node, folderId, newName) {
          
          if (node.folders) {
            for (let i = 0; i < node.folders.length; i++) {
              if (node.folders[i].id === folderId) {
                node.folders[i].name = newName;
                return true;
              }
            }
            
            
            for (const folder of node.folders) {
              if (this.renameFolderInTree(folder, folderId, newName)) {
                return true;
              }
            }
          }
          
          return false;
        },
        
        
        showToast(message, type = 'success') {
          const toast = { message, type };
          this.toasts.push(toast);
          
          
          setTimeout(() => {
            const index = this.toasts.indexOf(toast);
            if (index !== -1) {
              this.toasts.splice(index, 1);
            }
          }, 3000);
        }
      }
    });
    
    app.mount('#app');
  </script>
</body>
</html>